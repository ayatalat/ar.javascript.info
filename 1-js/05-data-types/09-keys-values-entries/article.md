
# Object.keys, values, entries

دعنا نبتعد قليلا عن بنىة البيانات الفردية ونتحدث عن التكرار عليها. 
لقد رأينا هؤلاء الدوال فى الفصل السابق  `map.keys()`, `map.values()`, `map.entries()`.

هؤلاء الدوال يتم استخدامهم بصورة عامه وهناك إتفاقية شائعه لإستخدامهم مع بنية البيانات.
وإذا أردنا أن نبنى بنية بيانات خاصه بنا فيجب علينا تصميمهم فى بنية البيانات الخاصة بنا.

:يتم دعم هؤلاء الدوال فى بنية البيانات التالية
- `Map`
- `Set`
- `Array`

يمكن أيضا للكائنات العادية أن تستخدم هؤلاء الطرق ولكن بتركيب مختلف قليلا.

## Object.keys, values, entries

متاح للكائنات العادية الدوال التالية: 

- [Object.keys(obj)](mdn:js/Object/keys) -- إرجاع مصفوفة من أسماء القيم.
- [Object.values(obj)](mdn:js/Object/values) -- إرجاع مصفوفة من القيم .
- [Object.entries(obj)](mdn:js/Object/entries) -- إرجاع مصفوفة أزواج من [إسم / قيمة]

:لاحظ الاختلاقات (مقارنة مع `map`على سبيل المثال)

|             | Map              | Object       |
|-------------|------------------|--------------|
| تركيب الجملة | `map.keys()`  | `Object.keys(obj)`, ليس `obj.keys()` |
| النتيجة     | كائن iterable     | "حقيقى" مصفوفه                     |

الإختلاف الأول أنه يجب علينا استدعاء  `Object.keys(obj)`, وليس  `obj.keys()`.

لماذا إذن ؟ السبب الرئيسى هو المرونة . تذكر أن الكائنات هى الأساس لكل الهياكل المعقده فى لغه Javascript .
لهذا يمكن أن يكون لدينا كائن مثل `data`والذى تم تصميم `data.values`الخاصه بيه . ومع ذلك نستطيع أيضا أن نستدعى `object.values(data)`

السبب الثانى هو أن  ناتج الدوال `*.Object`  هو مصفوفة حقيقه وليس مجرد كائن  قابله للتكرار وهذا لأسباب تاريخيه 

على سبيل المثال : 

```js
let user = {
  name: "John",
  age: 30
};
```

- `Object.keys(user) = ["name", "age"]`
- `Object.values(user) = ["John", 30]`
- `Object.entries(user) = [ ["name","John"], ["age",30] ]`

هذا مثال على إستخدام Object.values لتكرار على قيم الخصائص : 

```js run
let user = {
  name: "John",
  age: 30
};

// التكرار على القيم 
for (let value of Object.values(user)) {
  alert(value); // John, then 30
}
```

```warn header="Object.keys/values/entries تجاهل الخصائص الرمزية"
مثل حلقة for..in ، تتجاهل هذه الأساليب الخصائص التي تستخدم الرمز (...) كأسماء للقيم .
عادة ما يكون هذا مناسبًا. ولكن إذا كنت بحاجة إلى التفكير في أسماء القيم الرمزية ، فهناك طريقة Object.getOwnPropertySymbols منفصلة ، والتي تُرجع مجموعة من أسماء القيم الرمزية فقط. أيضًا ، هناك طريقة Reflect.ownKeys (obj) تقوم بإرجاع كافة أسماء القيم .
```


## تحولات الكائن

تفتقر الكائنات العديد من الدوال المتاحة للمصفوفات مثل`map`, `filter` وغيرها 

وإذا كنت ترغب فى استخدامهم على الكائنات يمكنك استخدام `Object.entries`ثم`Object.fromEntries`: 

1. إستخدم `Object.entries(obj)` للحصول على مصفوفه تتكون من قيم وأسماء من خلال `obj`
2. إستخدم دوال المصفوفات على هذه المصفوفه مثلا `map`
3. إستخدم`Object.fromEntries(array)` عندما يكون الناتج على شكل مصفوفة لتحويلها مره أخرى إلى كائن

على سبيل المثال , لدينا كائن يحتوى على الأسعار ونريد أن نضاعف هذه الأسعار :

```js run
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

*!*
let doublePrices = Object.fromEntries(
    // يتم تحويله الى مصفوفه وثم إلى خريطه وثم استخدام لتحويله الى كائن مره أخرى
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
*/!*

alert(doublePrices.meat); // 8
```
  قد يبدو الأمر معقد من الوهلة الأولى ولكن من السهل فهمه بعد تطبيقه أكتر من مرة .
ويكمننا ان نقوم بعمل تحويلات قوية  من خلال سطر واحد ولكن يجب أن تكون واضحة ومن السهل فهمها .  
